//This file was automatically generated by Makefile at https://github.com/cnlohr/cnfa
//Generated from files git hash dbe638e0c72e599cab6bc71c2bf0b6da216f50e6 on Thu Jun 13 11:55:47 UTC 2024 (This is not the git hash of this file)
//Copyright <>< 2010-2020 Charles Lohr (And other authors as cited)
//CNFA is licensed under the MIT/x11, ColorChord or NewBSD Licenses. You choose.
//
// CN's Platform-agnostic, foundational sound driver subsystem.
// Easily output and input sound on a variety of platforms.
//
// Options:
//  * #define CNFA_IMPLEMENTATION before this header and it will build all 
//    definitions in.
//


#ifndef _CNFA_H
#define _CNFA_H



//this #define is per-platform.  For instance on Linux, you have ALSA, Pulse and null
#define MAX_CNFA_DRIVERS 4

struct CNFADriver;

#ifdef __cplusplus
extern "C" {
#endif

#ifdef BUILD_DLL
	#ifdef WINDOWS
		#define DllExport __declspec( dllexport )
	#else
		#define DllExport extern
	#endif
#else
	#define DllExport
#endif

//NOTE: Some drivers have synchronous duplex mode, other drivers will use two different callbacks.  If ether is unavailable, it will be NULL.
//I.e. if `out` is null, only use in to read.  If in is null, only place samples in out.
typedef void(*CNFACBType)( struct CNFADriver * sd, short * out, short * in, int framesp, int framesr );

typedef void*(CNFAInitFn)( CNFACBType cb, const char * your_name, int reqSPSPlay, int reqSPSRec, int reqChannelsPlay, int reqChannelsRec, int sugBufferSize, const char * outputSelect, const char * inputSelect, void * opaque );

struct CNFADriver
{
	void (*CloseFn)( void * object );
	int (*StateFn)( void * object );
	CNFACBType callback;
	short channelsPlay;
	short channelsRec;
	int spsPlay;
	int spsRec;
	void * opaque;

	//More fields may exist on a per-sound-driver basis
};

//Accepts:
//If DriverName = 0 or empty, will try to find best driver.
//
// our_source_name is an optional argument, but on some platforms controls the name of your endpoint.
// reqSPSPlay = 44100 is guaranteed on many platforms.
// reqSPSRec = 44100 is guaranteed on many platforms.
//   NOTE: Some platforms do not allow SPS play and REC to deviate from each other.
// reqChannelsRec = 1 or 2 guaranteed on many platforms.
// reqChannelsPlay = 1 or 2 guaranteedon many platforms. NOTE: Some systems require ChannelsPlay == ChannelsRec!
// sugBufferSize = No promises.
// outputSelect = No standardization, NULL is OK for default.
// inputSelect = No standardization, NULL is OK for default.

DllExport struct CNFADriver * CNFAInit( const char * driver_name, const char * your_name, CNFACBType cb, int reqSPSPlay, int reqSPSRec, int reqChannelsPlay,
	int reqChannelsRec, int sugBufferSize, const char * outputSelect, const char * inputSelect, void * opaque );
	
DllExport int CNFAState( struct CNFADriver * cnfaobject ); //returns bitmask.  1 if mic recording, 2 if play back running, 3 if both running.
DllExport void CNFAClose( struct CNFADriver * cnfaobject );


//Called by various sound drivers.  Notice priority must be greater than 0.  Priority of 0 or less will not register.
//This is an internal function.  Applications shouldnot call it.
void RegCNFADriver( int priority, const char * name, CNFAInitFn * fn );

#if defined(_MSC_VER) && !defined(__clang__)
#define REGISTER_CNFA( cnfadriver, priority, name, function ) \
	void REGISTER##cnfadriver() { RegCNFADriver( priority, name, function ); }
#else
#define REGISTER_CNFA( cnfadriver, priority, name, function ) \
	void __attribute__((constructor)) REGISTER##cnfadriver() { RegCNFADriver( priority, name, function ); }
#endif

#if defined(WINDOWS) || defined(__WINDOWS__) || defined(_WINDOWS) \
                     || defined(_WIN32)      || defined(_WIN64) \
                     || defined(WIN32)       || defined(WIN64) \
                     || defined(__WIN32__)   || defined(__CYGWIN__) \
                     || defined(__MINGW32__) || defined(__MINGW64__) \
                     || defined(__TOS_WIN__)
#define CNFA_WINDOWS 1
#elif defined( ANDROID ) || defined( __android__ ) || defined(ANDROID)
#define CNFA_ANDROID 1
#elif defined(__NetBSD__) || defined(__NetBSD) || defined(__sun) || defined(sun)
#define CNFA_SUN 1
#elif defined(__linux) || defined(__linux__) || defined(linux) || defined(__LINUX__)
#define CNFA_LINUX 1
#endif

#if defined(PULSEAUDIO)
#define CNFA_PULSE 1
#endif

#ifdef __TINYC__
#ifndef TCC
#define TCC
#endif
#endif

#ifdef CNFA_IMPLEMENTATION
//Copyright <>< 2010-2020 Charles Lohr (And other authors as cited)
//CNFA is licensed under the MIT/x11, ColorChord or NewBSD Licenses. You choose.

#ifndef _CNFA_C
#define _CNFA_C

#include <string.h>
#include <stdio.h>
#include <stdlib.h>

#if defined(_MSC_VER)
#if CNFA_WINDOWS
#ifndef strdup
#define strdup _strdup
#endif
#endif 
#endif

static CNFAInitFn * CNFADrivers[MAX_CNFA_DRIVERS];
static char * CNFADriverNames[MAX_CNFA_DRIVERS];
static int CNFADriverPriorities[MAX_CNFA_DRIVERS];

void RegCNFADriver( int priority, const char * name, CNFAInitFn * fn )
{
	int j;

	if( priority <= 0 )
	{
		return;
	}

	printf("[CNFA] Registering Driver: %s\n", name);

	for( j = MAX_CNFA_DRIVERS-1; j >= 0; j-- )
	{
		//Cruise along, find location to insert
		if( j > 0 && ( !CNFADrivers[j-1] || CNFADriverPriorities[j-1] < priority ) )
		{
			CNFADrivers[j] = CNFADrivers[j-1];
			CNFADriverNames[j] = CNFADriverNames[j-1];
			CNFADriverPriorities[j] = CNFADriverPriorities[j-1];
		}
		else
		{
			CNFADrivers[j] = fn;
			CNFADriverNames[j] = strdup( name );
			CNFADriverPriorities[j] = priority;
			break;
		}
	}
}

struct CNFADriver * CNFAInit( const char * driver_name, const char * your_name, CNFACBType cb, int reqSPSPlay, int reqSPSRec,
	int reqChannelsPlay, int reqChannelsRec, int sugBufferSize, const char * outputSelect, const char * inputSelect, void * opaque)
{

#if CNFA_ANDROID
	//Android can't run static-time code.
	void REGISTERAndroidCNFA();
	REGISTERAndroidCNFA();
#endif

	int i;
	struct CNFADriver * ret = 0;
	int minprio = 0;
	CNFAInitFn * bestinit = 0;
	if( driver_name == 0 || strlen( driver_name ) == 0 )
	{
		//Search for a driver.
		for( i = 0; i < MAX_CNFA_DRIVERS; i++ )
		{
			if( CNFADrivers[i] == 0 )
			{
				break;
			}
			if( CNFADriverPriorities[i] > minprio )
			{
				minprio = CNFADriverPriorities[i];
				bestinit = CNFADrivers[i];
			}
		}
		if( bestinit )
		{
			ret = (struct CNFADriver *)bestinit( cb, your_name, reqSPSPlay, reqSPSRec, reqChannelsPlay, reqChannelsRec, sugBufferSize, outputSelect, inputSelect, opaque );
		}
		if( ret )
		{
			return ret;
		}
	}
	else
	{
		for( i = 0; i < MAX_CNFA_DRIVERS; i++ )
		{
			if( CNFADrivers[i] == 0 )
			{
				break;
			}
			if( strcmp( CNFADriverNames[i], driver_name ) == 0 )
			{
				return (struct CNFADriver *)CNFADrivers[i]( cb, your_name, reqSPSPlay, reqSPSRec, reqChannelsPlay, reqChannelsRec, sugBufferSize, outputSelect, inputSelect, opaque );
			}
		}
	}
	printf( "CNFA Driver not found.\n" );
	return 0;
}

int CNFAState( struct CNFADriver * cnfaobject )
{
	if( cnfaobject )
	{
		return cnfaobject->StateFn( cnfaobject );
	}
	return -1;
}

void CNFAClose( struct CNFADriver * cnfaobject )
{
	if( cnfaobject )
	{
		cnfaobject->CloseFn( cnfaobject );
	}
}

#endif



//Copyright 2015-2020 <>< Charles Lohr under the ColorChord License.

#include "os_generic.h"
#include <stdlib.h>

struct CNFADriverNull
{
	void (*CloseFn)( void * object );
	int (*StateFn)( void * object );
	CNFACBType callback;
	short channelsPlay;
	short channelsRec;
	int spsPlay;
	int spsRec;
	void * opaque;
};

void CloseCNFANull( void * object )
{
	free( object );
}

int CNFAStateNull( void * object )
{
	return 0;
}


void * InitCNFANull( CNFACBType cb, const char * your_name, int reqSPSPlay, int reqSPSRec, int reqChannelsPlay, int reqChannelsRec, int sugBufferSize, const char * outputSelect, const char * inputSelect, void * opaque )
{
	struct CNFADriverNull * r = (struct CNFADriverNull *)malloc( sizeof( struct CNFADriverNull ) );
	r->CloseFn = CloseCNFANull;
	r->StateFn = CNFAStateNull;
	r->callback = cb;
	r->spsPlay = reqSPSPlay;
	r->spsRec = reqSPSRec;
	r->opaque = opaque;
	r->channelsPlay = reqChannelsPlay;
	r->channelsRec = reqChannelsRec;
	return r;
}


REGISTER_CNFA( NullCNFA, 1, "NULL", InitCNFANull );


#if CNFA_WINDOWS
  #include "CNFA_winmm.c"
  #include <ntverp.h> // This probably won't work on pre-NT systems
  #if VER_PRODUCTBUILD >= 7601
    #include "CNFA_wasapi.c"
  #endif
#elif CNFA_ANDROID
//Copyright 2019-2020 <>< Charles Lohr under the ColorChord License, MIT/x11 license or NewBSD Licenses.
// This was originally to be used with rawdrawandroid

#include "os_generic.h"
#include <pthread.h> //Using android threads not os_generic threads.
#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

//based on https://github.com/android/ndk-samples/blob/master/native-audio/app/src/main/cpp/native-audio-jni.c

// for native audio
#include <SLES/OpenSLES.h>
#include <SLES/OpenSLES_Android.h>

#include <android_native_app_glue.h>
#include <jni.h>
#include <native_activity.h>

struct CNFADriverAndroid
{
	//Standard header - must remain.
	void (*CloseFn)( void * object );
	int (*StateFn)( void * object );
	CNFACBType callback;
	short channelsPlay;
	short channelsRec;
	int spsPlay;
	int spsRec;
	void * opaque;

	int buffsz;

	SLObjectItf engineObject;
	SLEngineItf engineEngine;
	SLRecordItf recorderRecord;
	SLObjectItf recorderObject;

	SLPlayItf playerPlay;
	SLObjectItf playerObject;
	SLObjectItf outputMixObject;
 
	SLAndroidSimpleBufferQueueItf recorderBufferQueue;
	SLAndroidSimpleBufferQueueItf playerBufferQueue;
	//unsigned recorderSize;

	int recorderBufferSizeBytes;
	int playerBufferSizeBytes;
	short * recorderBuffer;
	short * playerBuffer;
};


void bqRecorderCallback(SLAndroidSimpleBufferQueueItf bq, void *context)
{
	struct CNFADriverAndroid * r = (struct CNFADriverAndroid*)context;
	r->callback( (struct CNFADriver*)r, 0, r->recorderBuffer, 0, r->buffsz/(sizeof(short)*r->channelsRec) );
	(*r->recorderBufferQueue)->Enqueue( r->recorderBufferQueue, r->recorderBuffer, r->recorderBufferSizeBytes/(r->channelsRec*sizeof(short)) );
}

void bqPlayerCallback(SLAndroidSimpleBufferQueueItf bq, void *context)
{
	struct CNFADriverAndroid * r = (struct CNFADriverAndroid*)context;
	r->callback( (struct CNFADriver*)r, r->playerBuffer, 0, r->buffsz/(sizeof(short)*r->channelsPlay), 0 );
	(*r->playerBufferQueue)->Enqueue( r->playerBufferQueue, r->playerBuffer, r->playerBufferSizeBytes/(r->channelsPlay*sizeof(short)));
}

static struct CNFADriverAndroid* InitAndroidDriver( struct CNFADriverAndroid * r )
{
	SLresult result;
	printf( "Starting InitAndroidDriver\n" );
	
	// create engine
	result = slCreateEngine(&r->engineObject, 0, NULL, 0, NULL, NULL);
	assert(SL_RESULT_SUCCESS == result);
	(void)result;

	// realize the engine
	result = (*r->engineObject)->Realize(r->engineObject, SL_BOOLEAN_FALSE);
	assert(SL_RESULT_SUCCESS == result);
	(void)result;

	// get the engine interface, which is needed in order to create other objects
	result = (*r->engineObject)->GetInterface(r->engineObject, SL_IID_ENGINE, &r->engineEngine);
	assert(SL_RESULT_SUCCESS == result);
	(void)result;


	///////////////////////////////////////////////////////////////////////////////////////////////////////
	if( r->channelsPlay )
	{
		printf("create output mix");

		SLDataFormat_PCM format_pcm ={
			SL_DATAFORMAT_PCM,
			r->channelsPlay,
			r->spsPlay*1000,
			SL_PCMSAMPLEFORMAT_FIXED_16,
			SL_PCMSAMPLEFORMAT_FIXED_16,
			(r->channelsPlay==1)?SL_SPEAKER_FRONT_CENTER:3,
			SL_BYTEORDER_LITTLEENDIAN,
		};
		SLDataLocator_AndroidSimpleBufferQueue loc_bq_play = {SL_DATALOCATOR_ANDROIDSIMPLEBUFFERQUEUE, 2};
		SLDataSource source = {&loc_bq_play, &format_pcm};
		const SLInterfaceID ids[1] = {SL_IID_VOLUME};
		const SLboolean req[1] = {SL_BOOLEAN_TRUE};
		const SLInterfaceID id[1] = {SL_IID_ANDROIDSIMPLEBUFFERQUEUE};

		result = (*r->engineEngine)->CreateOutputMix(r->engineEngine, &r->outputMixObject, 0, ids, req);
		result = (*r->outputMixObject)->Realize(r->outputMixObject, SL_BOOLEAN_FALSE);

		SLDataLocator_OutputMix loc_outmix = { SL_DATALOCATOR_OUTPUTMIX, r->outputMixObject };
		SLDataSink sink;
		sink.pFormat = &format_pcm;
		sink.pLocator = &loc_outmix;

		// create audio player
		result = (*r->engineEngine)->CreateAudioPlayer(r->engineEngine, &r->playerObject, &source, &sink, 1, id, req);
		if (SL_RESULT_SUCCESS != result) {
			printf( "CreateAudioPlayer failed\n" );
			return JNI_FALSE;
		}


		// realize the audio player
		result = (*r->playerObject)->Realize(r->playerObject, SL_BOOLEAN_FALSE);
		if (SL_RESULT_SUCCESS != result) {
			printf( "AudioPlayer Realize failed: %d\n", result );
			return JNI_FALSE;
		}

		// get the player interface
		result = (*r->playerObject)->GetInterface(r->playerObject, SL_IID_PLAY, &r->playerPlay);
		assert(SL_RESULT_SUCCESS == result);
		(void)result;

		// get the buffer queue interface
		result = (*r->playerObject)->GetInterface(r->playerObject, SL_IID_ANDROIDSIMPLEBUFFERQUEUE, &r->playerBufferQueue);
		assert(SL_RESULT_SUCCESS == result);
		(void)result;

		// register callback on the buffer queue
		result = (*r->playerBufferQueue)->RegisterCallback(r->playerBufferQueue, bqPlayerCallback, r);
		assert(SL_RESULT_SUCCESS == result);
		(void)result;

		printf( "===================== Player init ok.\n" );
	}

	if( r->channelsRec )
	{
		// configure audio source
		SLDataLocator_IODevice loc_devI = {SL_DATALOCATOR_IODEVICE, SL_IODEVICE_AUDIOINPUT, SL_DEFAULTDEVICEID_AUDIOINPUT, NULL};
		SLDataSource audioSrc = {&loc_devI, NULL};

		// configure audio sink
		SLDataFormat_PCM format_pcm ={
			SL_DATAFORMAT_PCM,
			r->channelsRec, 
			r->spsRec*1000,
			SL_PCMSAMPLEFORMAT_FIXED_16,
			SL_PCMSAMPLEFORMAT_FIXED_16,
			(r->channelsRec==1)?SL_SPEAKER_FRONT_CENTER:3,
			SL_BYTEORDER_LITTLEENDIAN,
		};
		SLDataLocator_AndroidSimpleBufferQueue loc_bq = {SL_DATALOCATOR_ANDROIDSIMPLEBUFFERQUEUE, 2};
		SLDataSink audioSnk = {&loc_bq, &format_pcm};


		const SLInterfaceID id[1] = {SL_IID_ANDROIDSIMPLEBUFFERQUEUE};
		const SLboolean req[1] = {SL_BOOLEAN_TRUE};

		result = (*r->engineEngine)->CreateAudioRecorder(r->engineEngine, &r->recorderObject, &audioSrc, &audioSnk, 1, id, req);
		if (SL_RESULT_SUCCESS != result) {
			printf( "CreateAudioRecorder failed\n" );
			return JNI_FALSE;
		}

		// realize the audio recorder
		result = (*r->recorderObject)->Realize(r->recorderObject, SL_BOOLEAN_FALSE);
		if (SL_RESULT_SUCCESS != result) {
			printf( "AudioRecorder Realize failed: %d\n", result );
			return JNI_FALSE;
		}

		// get the record interface
		result = (*r->recorderObject)->GetInterface(r->recorderObject, SL_IID_RECORD, &r->recorderRecord);
		assert(SL_RESULT_SUCCESS == result);
		(void)result;

		// get the buffer queue interface
		result = (*r->recorderObject)->GetInterface(r->recorderObject, SL_IID_ANDROIDSIMPLEBUFFERQUEUE,	&r->recorderBufferQueue);
		assert(SL_RESULT_SUCCESS == result);
		(void)result;

		// register callback on the buffer queue
		result = (*r->recorderBufferQueue)->RegisterCallback(r->recorderBufferQueue, bqRecorderCallback, r);
		assert(SL_RESULT_SUCCESS == result);
		(void)result;
	}


	if( r->playerPlay )
	{
		result = (*r->playerPlay)->SetPlayState(r->playerPlay, SL_PLAYSTATE_STOPPED);
		assert(SL_RESULT_SUCCESS == result); (void)result;
		result = (*r->playerBufferQueue)->Clear(r->playerBufferQueue);
		assert(SL_RESULT_SUCCESS == result); (void)result;
		r->playerBuffer = malloc( r->playerBufferSizeBytes );
		memset( r->playerBuffer, 0, r->playerBufferSizeBytes );
		result = (*r->playerBufferQueue)->Enqueue(r->playerBufferQueue, r->playerBuffer, r->playerBufferSizeBytes );
		assert(SL_RESULT_SUCCESS == result); (void)result;
		result = (*r->playerPlay)->SetPlayState(r->playerPlay, SL_PLAYSTATE_PLAYING);
		assert(SL_RESULT_SUCCESS == result); (void)result;
	}


	if( r->recorderRecord )
	{
		result = (*r->recorderRecord)->SetRecordState(r->recorderRecord, SL_RECORDSTATE_STOPPED);
		assert(SL_RESULT_SUCCESS == result); (void)result;
		result = (*r->recorderBufferQueue)->Clear(r->recorderBufferQueue);
		assert(SL_RESULT_SUCCESS == result); (void)result;
		// the buffer is not valid for playback yet

		r->recorderBuffer = malloc( r->recorderBufferSizeBytes );

		// enqueue an empty buffer to be filled by the recorder
		// (for streaming recording, we would enqueue at least 2 empty buffers to start things off)
		result = (*r->recorderBufferQueue)->Enqueue(r->recorderBufferQueue, r->recorderBuffer, r->recorderBufferSizeBytes );
		// the most likely other result is SL_RESULT_BUFFER_INSUFFICIENT,
		// which for this code example would indicate a programming error
		assert(SL_RESULT_SUCCESS == result); (void)result;

		// start recording
		result = (*r->recorderRecord)->SetRecordState(r->recorderRecord, SL_RECORDSTATE_RECORDING);
		assert(SL_RESULT_SUCCESS == result); (void)result;
	}


	printf( "Complete Init Sound Android\n" );
	return r;
}

int CNFAStateAndroid( void * v )
{
	struct CNFADriverAndroid * soundobject = (struct CNFADriverAndroid *)v;
	return ((soundobject->recorderObject)?1:0) | ((soundobject->playerObject)?2:0);
}

void CloseCNFAAndroid( void * v )
{
	struct CNFADriverAndroid * r = (struct CNFADriverAndroid *)v;
    // destroy audio recorder object, and invalidate all associated interfaces
    if (r->recorderObject != NULL) {
        (*r->recorderObject)->Destroy(r->recorderObject);
        r->recorderObject = NULL;
        r->recorderRecord = NULL;
        r->recorderBufferQueue = NULL;
		if( r->recorderBuffer ) free( r->recorderBuffer );
    }


    if (r->playerObject != NULL) {
        (*r->playerObject)->Destroy(r->playerObject);
        r->playerObject = NULL;
        r->playerPlay = NULL;
        r->playerBufferQueue = NULL;
		if( r->playerBuffer ) free( r->playerBuffer );
    }


    // destroy engine object, and invalidate all associated interfaces
    if (r->engineObject != NULL) {
        (*r->engineObject)->Destroy(r->engineObject);
        r->engineObject = NULL;
        r->engineEngine = NULL;
    }

}


int AndroidHasPermissions(const char* perm_name);
void AndroidRequestAppPermissions(const char * perm);


void * InitCNFAAndroid( CNFACBType cb, const char * your_name, int reqSPSPlay, int reqSPSRec, int reqChannelsPlay, int reqChannelsRec, int sugBufferSize, const char * outputSelect, const char * inputSelect, void * opaque )
{
	struct CNFADriverAndroid * r = (struct CNFADriverAndroid *)malloc( sizeof( struct CNFADriverAndroid ) );
	memset( r, 0, sizeof( *r) );
	r->CloseFn = CloseCNFAAndroid;
	r->StateFn = CNFAStateAndroid;
	r->callback = cb;
	r->opaque = opaque;
	r->channelsPlay = reqChannelsPlay;
	r->channelsRec = reqChannelsRec;
	r->spsRec = reqSPSRec;
	r->spsPlay = reqSPSPlay;
	
	r->recorderBufferSizeBytes = sugBufferSize * 2 * r->channelsRec;
	r->playerBufferSizeBytes = sugBufferSize * 2 * r->channelsPlay;

	int hasperm = AndroidHasPermissions( "RECORD_AUDIO" );
	if( !hasperm )
	{
		AndroidRequestAppPermissions( "RECORD_AUDIO" );
	}
	
	r->buffsz = sugBufferSize;

	return InitAndroidDriver(r);
}

//Tricky: On Android, this can't actually run before main.  Have to manually execute it.

REGISTER_CNFA( AndroidCNFA, 10, "ANDROID", InitCNFAAndroid );


#elif CNFA_SUN
//Copyright 2015-2020 <>< Charles Lohr under the MIT/x11, NewBSD or ColorChord License.  You choose.

#include "os_generic.h"
#include <sys/audioio.h>
#include <sys/ioctl.h>
#include <fcntl.h>
#include <string.h>
#include <errno.h>

struct CNFADriverSun
{
	void (*CloseFn)( void * object );
	int (*StateFn)( void * object );
	CNFACBType callback;
	short channelsPlay;
	short channelsRec;
	int spsPlay;
	int spsRec;
	void * opaque;

	char * devRec;
	char * devPlay;

	short * samplesRec;
	short * samplesPlay;

	og_thread_t threadPlay;
	og_thread_t threadRec;
	int bufsize;
	int playback_handle;
	int record_handle;

	char playing;
	char recording;
};

int CNFAStateSun( void * v )
{
	struct CNFADriverSun * r = (struct CNFADriverSun *)v;
	return ((r->playing)?2:0) | ((r->recording)?1:0);
}

void CloseCNFASun( void * v )
{
	struct CNFADriverSun * r = (struct CNFADriverSun *)v;
	if( r )
	{
		if( r->threadPlay ) OGJoinThread( r->threadPlay );
		if( r->threadRec ) OGJoinThread( r->threadRec );

		OGUSleep(2000);

		if( r->playback_handle != -1 ) close (r->playback_handle);
		if( r->record_handle != -1 ) close (r->record_handle);

		OGUSleep(2000);

		free( r->devRec );
		free( r->devPlay );
		free( r->samplesRec );
		free( r->samplesPlay );
		free( r );
	}
}


void * RecThread( void * v )
{
	struct CNFADriverSun * r = (struct CNFADriverSun *)v;
	size_t nbytes = r->bufsize * (2 * r->channelsRec);
	do
	{
		int nread = read( r->record_handle, r->samplesRec, nbytes );
		if( nread < 0 )
		{
			fprintf( stderr, "Warning: Sun Recording Failed\n" );
			break;
		}
		r->recording = 1;
		r->callback( (struct CNFADriver *)r, NULL, r->samplesRec, 0, (nread / 2) / r->channelsRec);
	} while( 1 );
	r->recording = 0;
	fprintf( stderr, "Sun Recording Stopped\n" );
	return 0;
}

void * PlayThread( void * v )
{
	struct CNFADriverSun * r = (struct CNFADriverSun *)v;
	size_t nbytes = r->bufsize * (2 * r->channelsPlay);
	int err;

	r->callback( (struct CNFADriver *)r, r->samplesPlay, NULL, r->bufsize, 0 );
	err = write( r->playback_handle, r->samplesPlay, nbytes );

	while( err >= 0 )
	{
		r->callback( (struct CNFADriver *)r, r->samplesPlay, NULL, r->bufsize, 0 );
		err = write( r->playback_handle, r->samplesPlay, nbytes );
		r->playing = 1;
	}
	r->playing = 0;
	fprintf( stderr, "Sun Playback Stopped\n" );
	return 0;
}

static struct CNFADriverSun * InitSun( struct CNFADriverSun * r )
{
	const char * devPlay = r->devPlay;
	const char * devRec = r->devRec;
	struct audio_info rinfo, pinfo;

	if( devRec == NULL || strcmp ( devRec, "default" ) == 0 )
	{
		devRec = "/dev/audio";
	}

	if( devPlay == NULL || strcmp ( devPlay , "default" ) == 0 )
	{
		devPlay = "/dev/audio";
	}

	printf( "CNFA Sun Init -> devPlay: %s, channelsPlay: %d, spsPlay: %d, devRec: %s, channelsRec: %d, spsRec: %d\n", devPlay, r->channelsPlay, r->spsPlay, devRec, r->channelsRec, r->spsRec);

	if( r->channelsPlay && r->channelsRec && strcmp (devPlay, devRec) == 0 )
	{
		if ( (r->playback_handle = r->record_handle = open (devPlay, O_RDWR)) < 0 )
		{
			fprintf (stderr, "cannot open audio device (%s)\n", 
				 strerror (errno));
			goto fail;
		}
	}
	else
	{
		if( r->channelsPlay )
		{
			if ( (r->playback_handle = open (devPlay, O_WRONLY)) < 0 )
			{
				fprintf (stderr, "cannot open output audio device %s (%s)\n", 
					 r->devPlay, strerror (errno));
				goto fail;
			}
		}

		if( r->channelsRec )
		{
			if ( (r->record_handle = open (devRec, O_RDONLY)) < 0 )
			{
				fprintf (stderr, "cannot open input audio device %s (%s)\n", 
					 r->devRec, strerror (errno));
				goto fail;
			}
		}
	}

	if( r->playback_handle )
	{
		AUDIO_INITINFO(&pinfo);

		pinfo.play.precision = 16;
		pinfo.play.encoding = AUDIO_ENCODING_LINEAR;
		pinfo.play.sample_rate = r->spsPlay;
		pinfo.play.channels = r->channelsPlay;

		if ( ioctl(r->playback_handle, AUDIO_SETINFO, &pinfo) < 0 )
		{
			fprintf (stderr, "cannot set audio playback format (%s)\n",
				 strerror (errno));
			goto fail;
		}

		if ( ioctl(r->playback_handle, AUDIO_GETINFO, &pinfo) < 0 )
		{
			fprintf (stderr, "cannot get audio record format (%s)\n",
				 strerror (errno));
			goto fail;
		}

		r->spsPlay = pinfo.play.sample_rate;
		r->channelsPlay = pinfo.play.channels;

		if ( (r->samplesPlay = calloc(2 * r->channelsPlay, r->bufsize)) == NULL )
		{
			goto fail;
		}
	}

	if( r->record_handle )
	{
		AUDIO_INITINFO(&rinfo);

		rinfo.record.precision = 16;
		rinfo.record.encoding = AUDIO_ENCODING_LINEAR;
		rinfo.record.sample_rate = r->spsRec;
		rinfo.record.channels = r->channelsRec;

		if ( ioctl(r->record_handle, AUDIO_SETINFO, &rinfo) < 0 )
		{
			fprintf (stderr, "cannot set audio record format (%s)\n",
				 strerror (errno));
			goto fail;
		}

		if ( ioctl(r->record_handle, AUDIO_GETINFO, &rinfo) < 0 )
		{
			fprintf (stderr, "cannot get audio record format (%s)\n",
				 strerror (errno));
			goto fail;
		}

		r->spsRec = rinfo.record.sample_rate;
		r->channelsRec = rinfo.record.channels;

		if ( (r->samplesRec = calloc(2 * r->channelsRec, r->bufsize)) == NULL )
		{
			goto fail;
		}
	}

	if( r->playback_handle )
	{
		r->threadPlay = OGCreateThread( PlayThread, r );
	}

	if( r->record_handle )
	{
		r->threadRec = OGCreateThread( RecThread, r );
	}

	printf( "CNFA Sun Init Out -> channelsPlay: %d, spsPlay: %d, channelsRec: %d, spsRec: %d\n", r->channelsPlay, r->spsPlay, r->channelsRec, r->spsRec);

	return r;

fail:
	if( r )
	{
		if( r->playback_handle != -1 ) close (r->playback_handle);
		if( r->record_handle != -1 ) close (r->record_handle);
		free( r->samplesPlay );
		free( r->samplesRec );
		free( r );
	}
	return 0;
}



void * InitSunDriver( CNFACBType cb, const char * your_name, int reqSPSPlay, int reqSPSRec, int reqChannelsPlay, int reqChannelsRec, int sugBufferSize, const char * outputSelect, const char * inputSelect, void * opaque )
{
	struct CNFADriverSun * r = (struct CNFADriverSun *)malloc( sizeof( struct CNFADriverSun ) );

	r->CloseFn = CloseCNFASun;
	r->StateFn = CNFAStateSun;
	r->callback = cb;
	r->opaque = opaque;
	r->spsPlay = reqSPSPlay;
	r->spsRec = reqSPSRec;
	r->channelsPlay = reqChannelsPlay;
	r->channelsRec = reqChannelsRec;

	r->devRec = (inputSelect)?strdup(inputSelect):0;
	r->devPlay = (outputSelect)?strdup(outputSelect):0;

	r->samplesPlay = NULL;
	r->samplesRec = NULL;

	r->playback_handle = -1;
	r->record_handle = -1;
	r->bufsize = sugBufferSize;

	return InitSun(r);
}

REGISTER_CNFA( SUN, 10, "Sun", InitSunDriver );


#elif CNFA_LINUX
//Copyright 2015-2020 <>< Charles Lohr under the MIT/x11, NewBSD or ColorChord License.  You choose.

#include "os_generic.h"
#include <alsa/asoundlib.h>
#include <string.h>

struct CNFADriverAlsa
{
	void (*CloseFn)( void * object );
	int (*StateFn)( void * object );
	CNFACBType callback;
	short channelsPlay;
	short channelsRec;
	int spsPlay;
	int spsRec;
	void * opaque;

	char * devRec;
	char * devPlay;

	snd_pcm_uframes_t bufsize;
	og_thread_t threadPlay;
	og_thread_t threadRec;
	snd_pcm_t *playback_handle;
	snd_pcm_t *record_handle;

	char playing;
	char recording;
};

int CNFAStateAlsa( void * v )
{
	struct CNFADriverAlsa * r = (struct CNFADriverAlsa *)v;
	return ((r->playing)?2:0) | ((r->recording)?1:0);
}

void CloseCNFAAlsa( void * v )
{
	struct CNFADriverAlsa * r = (struct CNFADriverAlsa *)v;
	if( r )
	{
		if( r->threadPlay ) OGJoinThread( r->threadPlay );
		if( r->threadRec ) OGJoinThread( r->threadRec );

		OGUSleep(2000);

		if( r->playback_handle ) snd_pcm_close (r->playback_handle);
		if( r->record_handle ) snd_pcm_close (r->record_handle);

		OGUSleep(2000);

		if( r->devRec ) free( r->devRec );
		if( r->devPlay ) free( r->devPlay );
		free( r );
	}
}


static int SetHWParams( snd_pcm_t * handle, int * samplerate, short * channels, snd_pcm_uframes_t * bufsize, struct CNFADriverAlsa * a )
{
	int err;
	int bufs;
	int dir;
	snd_pcm_hw_params_t *hw_params;
	if ((err = snd_pcm_hw_params_malloc (&hw_params)) < 0) {
		fprintf (stderr, "cannot allocate hardware parameter structure (%s)\n",
			 snd_strerror (err));
		return -1;
	}

	if ((err = snd_pcm_hw_params_any (handle, hw_params)) < 0) {
		fprintf (stderr, "cannot initialize hardware parameter structure (%s)\n",
			 snd_strerror (err));
		goto fail;
	}

	if ((err = snd_pcm_hw_params_set_access (handle, hw_params, SND_PCM_ACCESS_RW_INTERLEAVED)) < 0) {
		fprintf (stderr, "cannot set access type (%s)\n",
			 snd_strerror (err));
		goto fail;
	}

	if ((err = snd_pcm_hw_params_set_format (handle, hw_params,  SND_PCM_FORMAT_S16_LE )) < 0) {
		fprintf (stderr, "cannot set sample format (%s)\n",
			 snd_strerror (err));
		goto fail;
	}

	if ((err = snd_pcm_hw_params_set_rate_near (handle, hw_params, (unsigned int*)samplerate, 0)) < 0) {
		fprintf (stderr, "cannot set sample rate (%s)\n",
			 snd_strerror (err));
		goto fail;
	}

	if ((err = snd_pcm_hw_params_set_channels (handle, hw_params, *channels)) < 0) {
		fprintf (stderr, "cannot set channel count (%s)\n",
			 snd_strerror (err));
		goto fail;
	}

	dir = 0;
	if( (err = snd_pcm_hw_params_set_period_size_near(handle, hw_params, bufsize, &dir)) < 0 )
	{
		fprintf( stderr, "cannot set period size. (%s)\n",
			snd_strerror(err) );
		goto fail;
	}

	//NOTE: This step is critical for low-latency sound.
	bufs = *bufsize*3;
	if( (err = snd_pcm_hw_params_set_buffer_size(handle, hw_params, bufs)) < 0 )
	{
		fprintf( stderr, "cannot set snd_pcm_hw_params_set_buffer_size size. (%s)\n",
			snd_strerror(err) );
		goto fail;
	}


	if ((err = snd_pcm_hw_params (handle, hw_params)) < 0) {
		fprintf (stderr, "cannot set parameters (%s)\n",
			 snd_strerror (err));
		goto fail;
	}

	snd_pcm_hw_params_free (hw_params);
	return 0;
fail:
	snd_pcm_hw_params_free (hw_params);
	return -2;
}


static int SetSWParams( struct CNFADriverAlsa * d, snd_pcm_t * handle, int isrec )
{
	snd_pcm_sw_params_t *sw_params;
	int err;
	//Time for software parameters:

	if( !isrec )
	{
		if ((err = snd_pcm_sw_params_malloc (&sw_params)) < 0) {
			fprintf (stderr, "cannot allocate software parameters structure (%s)\n",
				 snd_strerror (err));
			goto failhard;
		}
		if ((err = snd_pcm_sw_params_current (handle, sw_params)) < 0) {
			fprintf (stderr, "cannot initialize software parameters structure (%s) (%p)\n", 
				 snd_strerror (err), handle);
			goto fail;
		}

		int buffer_size = d->bufsize*3;
		int period_size = d->bufsize;
		printf( "PERIOD: %d  BUFFER: %d\n", period_size, buffer_size );

		if ((err = snd_pcm_sw_params_set_avail_min (handle, sw_params, period_size )) < 0) {
			fprintf (stderr, "cannot set minimum available count (%s)\n",
				 snd_strerror (err));
			goto fail;
		}
		//if ((err = snd_pcm_sw_params_set_stop_threshold(handle, sw_params, 512 )) < 0) {
		//	fprintf (stderr, "cannot set minimum available count (%s)\n",
		//		 snd_strerror (err));
		//	goto fail;
		//}
		if ((err = snd_pcm_sw_params_set_start_threshold(handle, sw_params, buffer_size - period_size )) < 0) {
			fprintf (stderr, "cannot set minimum available count (%s)\n",
				 snd_strerror (err));
			goto fail;
		}
		if ((err = snd_pcm_sw_params (handle, sw_params)) < 0) {
			fprintf (stderr, "cannot set software parameters (%s)\n",
				 snd_strerror (err));
			goto fail;
		}

		

	}

	if ((err = snd_pcm_prepare (handle)) < 0) {
		fprintf (stderr, "cannot prepare audio interface for use (%s)\n",
			 snd_strerror (err));
		goto fail;
	}

	return 0;
fail:
	if( !isrec )
	{
		snd_pcm_sw_params_free (sw_params);
	}
failhard:
	return -1;
}

void * RecThread( void * v )
{
	struct CNFADriverAlsa * r = (struct CNFADriverAlsa *)v;
	short samples[r->bufsize * r->channelsRec];
	snd_pcm_start(r->record_handle);
	do
	{
		int err = snd_pcm_readi( r->record_handle, samples, r->bufsize );	
		if( err < 0 )
		{
			fprintf( stderr, "Warning: ALSA Recording Failed\n" );
			break;
		}
		if( err != r->bufsize )
		{
			fprintf( stderr, "Warning: ALSA Recording Underflow\n" );
		}
		r->recording = 1;
		r->callback( (struct CNFADriver *)r, 0, samples, 0, err );
	} while( 1 );
	r->recording = 0;
	fprintf( stderr, "ALSA Recording Stopped\n" );
	return 0;
}

void * PlayThread( void * v )
{
	struct CNFADriverAlsa * r = (struct CNFADriverAlsa *)v;
	short samples[r->bufsize * r->channelsPlay];
	int err;
	//int total_avail = snd_pcm_avail(r->playback_handle);

	snd_pcm_start(r->playback_handle);
	r->callback( (struct CNFADriver *)r, samples, 0, r->bufsize, 0 );
	err = snd_pcm_writei(r->playback_handle, samples, r->bufsize);

	while( err >= 0 )
	{
	//	int avail = snd_pcm_avail(r->playback_handle);
	//	printf( "avail: %d\n", avail );
		r->callback( (struct CNFADriver *)r, samples, 0, r->bufsize, 0 );
		err = snd_pcm_writei(r->playback_handle, samples, r->bufsize);
		if( err != r->bufsize )
		{
			fprintf( stderr, "Warning: ALSA Playback Overflow\n" );
		}
		r->playing = 1;
	}
	r->playing = 0;
	fprintf( stderr, "ALSA Playback Stopped\n" );
	return 0;
}

static struct CNFADriverAlsa * InitALSA( struct CNFADriverAlsa * r )
{
	printf( "CNFA Alsa Init %p %p  (%d %d) %d %d\n", r->playback_handle, r->record_handle, r->spsPlay, r->spsRec, r->channelsPlay, r->channelsRec );

	int err;
	if( r->channelsPlay )
	{
		if ((err = snd_pcm_open (&r->playback_handle, r->devPlay?r->devPlay:"default", SND_PCM_STREAM_PLAYBACK, 0)) < 0) {
			fprintf (stderr, "cannot open output audio device (%s)\n", 
				 snd_strerror (err));
			goto fail;
		}
	}

	if( r->channelsRec )
	{
		if ((err = snd_pcm_open (&r->record_handle, r->devRec?r->devRec:"default", SND_PCM_STREAM_CAPTURE, 0)) < 0) {
			fprintf (stderr, "cannot open input audio device (%s)\n", 
				 snd_strerror (err));
			goto fail;
		}
	}

	printf( "%p %p\n", r->playback_handle, r->record_handle );

	if( r->playback_handle )
	{
		if( SetHWParams( r->playback_handle, &r->spsPlay, &r->channelsPlay, &r->bufsize, r ) < 0 ) 
			goto fail;
		if( SetSWParams( r, r->playback_handle, 0 ) < 0 )
			goto fail;
	}

	if( r->record_handle )
	{
		if( SetHWParams( r->record_handle, &r->spsRec, &r->channelsRec, &r->bufsize, r ) < 0 )
			goto fail;
		if( SetSWParams( r, r->record_handle, 1 ) < 0 )
			goto fail;
	}

#if 0
	if( r->playback_handle )
	{
		snd_async_handler_t *pcm_callback;
		//Handle automatically cleaned up when stream closed.
		err = snd_async_add_pcm_handler(&pcm_callback, r->playback_handle, playback_callback, r);
		if(err < 0)
		{
			printf("Playback callback handler error: %s\n", snd_strerror(err));
		}
	}

	if( r->record_handle )
	{
		snd_async_handler_t *pcm_callback;
		//Handle automatically cleaned up when stream closed.
		err = snd_async_add_pcm_handler(&pcm_callback, r->record_handle, record_callback, r);
		if(err < 0)
		{
			printf("Record callback handler error: %s\n", snd_strerror(err));
		}
	}
#endif

	if( r->playback_handle && r->record_handle )
	{
		err = snd_pcm_link ( r->playback_handle, r->record_handle );
		if(err < 0)
		{
			printf("snd_pcm_link error: %s\n", snd_strerror(err));
		}
	}

	if( r->playback_handle )
	{
		r->threadPlay = OGCreateThread( PlayThread, r );
	}

	if( r->record_handle )
	{
		r->threadRec = OGCreateThread( RecThread, r );
	}

	printf( "CNFA Alsa Init Out -> %p %p  (%d %d) %d %d\n", r->playback_handle, r->record_handle, r->spsPlay, r->spsRec, r->channelsPlay, r->channelsRec );

	return r;

fail:
	if( r )
	{
		if( r->playback_handle ) snd_pcm_close (r->playback_handle);
		if( r->record_handle ) snd_pcm_close (r->record_handle);
		free( r );
	}
	fprintf( stderr, "Error: ALSA failed to start.\n" );
	return 0;
}



void * InitALSADriver( CNFACBType cb, const char * your_name, int reqSPSPlay, int reqSPSRec, int reqChannelsPlay, int reqChannelsRec, int sugBufferSize, const char * outputSelect, const char * inputSelect, void * opaque )
{
	struct CNFADriverAlsa * r = (struct CNFADriverAlsa *)malloc( sizeof( struct CNFADriverAlsa ) );

	r->CloseFn = CloseCNFAAlsa;
	r->StateFn = CNFAStateAlsa;
	r->callback = cb;
	r->opaque = opaque;
	r->spsPlay = reqSPSPlay;
	r->spsRec = reqSPSRec;
	r->channelsPlay = reqChannelsPlay;
	r->channelsRec = reqChannelsRec;

	r->devRec = (inputSelect)?strdup(inputSelect):0;
	r->devPlay = (outputSelect)?strdup(outputSelect):0;

	r->playback_handle = 0;
	r->record_handle = 0;
	r->bufsize = sugBufferSize;

	return InitALSA(r);
}

REGISTER_CNFA( ALSA, 10, "ALSA", InitALSADriver );


#if CNFA_PULSE
//Copyright 2015-2020 <>< Charles Lohr under the MIT/x11, NewBSD or ColorChord License.  You choose.

//This file is really rough.  Full duplex doesn't seem to work hardly at all.


#include "os_generic.h"
#include <stdlib.h>

#include <pulse/simple.h>
#include <pulse/pulseaudio.h>
#include <pulse/error.h>
#include <stdio.h>
#include <string.h>

#define BUFFERSETS 3


//from http://www.freedesktop.org/wiki/Software/PulseAudio/Documentation/Developer/Clients/Samples/AsyncPlayback/
//also http://maemo.org/api_refs/5.0/5.0-final/pulseaudio/pacat_8c-example.html


struct CNFADriverPulse
{
	void (*CloseFn)( void * object );
	int (*StateFn)( void * object );
	CNFACBType callback;
	short channelsPlay;
	short channelsRec;
	int spsPlay;
	int spsRec;
	void * opaque;

	char * sourceNamePlay;
	char * sourceNameRec;

	og_thread_t thread;
 	pa_stream *  	play;
 	pa_stream *  	rec;
	pa_context *  pa_ctx;
	pa_mainloop *pa_ml;
	int pa_ready;
	int buffer;
	//More fields may exist on a per-sound-driver basis
};




int CNFAStatePulse( void * v )
{
	struct CNFADriverPulse * soundobject = (struct CNFADriverPulse *)v;
	return ((soundobject->play)?2:0) | ((soundobject->rec)?1:0);
}

void CloseCNFAPulse( void * v )
{
	struct CNFADriverPulse * r = (struct CNFADriverPulse *)v;
	if( r )
	{
		OGCancelThread( r->thread );

		OGUSleep(2000);

		if( r->play )
		{
			pa_stream_unref (r->play);
			r->play = 0;
		}

		if( r->rec )
		{
			pa_stream_unref (r->rec);
			r->rec = 0;
		}

		OGUSleep(2000);

		if( r->sourceNamePlay ) free( r->sourceNamePlay );
		if( r->sourceNameRec ) free( r->sourceNameRec );
		free( r );
	}
}

static void * CNFAThread( void * v )
{
	struct CNFADriverPulse * r = (struct CNFADriverPulse*)v;
	while(1)
	{
		pa_mainloop_iterate( r->pa_ml, 1, NULL );
	}
	return 0;
}

static void stream_request_cb(pa_stream *s, size_t length, void *userdata)
{
	struct CNFADriverPulse * r = (struct CNFADriverPulse*)userdata;
	if( !r->play )
	{
		return;
	}
	short bufp[length*r->channelsPlay/sizeof(short)];
	r->callback( (struct CNFADriver*)r, bufp, 0, length/(sizeof(short)*r->channelsPlay), 0 );
	pa_stream_write(r->play, &bufp[0], length, NULL, 0LL, PA_SEEK_RELATIVE);
}


static void stream_record_cb(pa_stream *s, size_t length, void *userdata)
{
	struct CNFADriverPulse * r = (struct CNFADriverPulse*)userdata;

	uint16_t * bufr;

    if (pa_stream_peek(r->rec, (const void**)&bufr, &length) < 0) {
        fprintf(stderr, ("pa_stream_peek() failed: %s\n"), pa_strerror(pa_context_errno(r->pa_ctx)));
        return;
    }

	short * buffer;
    buffer = (short*)pa_xmalloc(length);
    memcpy(buffer, bufr, length);
	pa_stream_drop(r->rec);
	r->callback( (struct CNFADriver*)r, 0, buffer, 0, length/(sizeof(short)*r->channelsRec) );
	pa_xfree( buffer );
}



static void stream_underflow_cb(pa_stream *s, void *userdata) {
  printf("underflow\n");
}


void pa_state_cb(pa_context *c, void *userdata) {
	pa_context_state_t state;
	int *pa_ready = (int*)userdata;
	state = pa_context_get_state(c);
	switch  (state) {
		// These are just here for reference
		case PA_CONTEXT_UNCONNECTED:
		case PA_CONTEXT_CONNECTING:
		case PA_CONTEXT_AUTHORIZING:
		case PA_CONTEXT_SETTING_NAME:
		default:
			break;
		case PA_CONTEXT_FAILED:
		case PA_CONTEXT_TERMINATED:
			*pa_ready = 2;
			break;
		case PA_CONTEXT_READY:
			*pa_ready = 1;
		break;
	}
}


void * InitCNFAPulse( CNFACBType cb, const char * your_name, int reqSPSPlay, int reqSPSRec, int reqChannelsPlay, int reqChannelsRec, int sugBufferSize, const char * outputSelect, const char * inputSelect, void * opaque )
{
	static pa_buffer_attr bufattr;
	static pa_sample_spec ss;
	int error;
	pa_mainloop_api *pa_mlapi;
	const char * title = your_name;

	struct CNFADriverPulse * r = (struct CNFADriverPulse *)malloc( sizeof( struct CNFADriverPulse ) );

	r->pa_ml = pa_mainloop_new();
	if( !r->pa_ml )
	{
		fprintf( stderr, "Failed to initialize pa_mainloop_new()\n" );
		goto fail;
	}

	pa_mlapi = pa_mainloop_get_api(r->pa_ml);
	if( !pa_mlapi )
	{
		fprintf( stderr, "Failed to initialize pa_mainloop_get_api()\n" );
		goto fail;
	}

	r->pa_ctx = pa_context_new(pa_mlapi, title );
	pa_context_connect(r->pa_ctx, NULL, PA_CONTEXT_NOFLAGS, NULL);

	//TODO: pa_context_set_state_callback

	r->CloseFn = CloseCNFAPulse;
	r->StateFn = CNFAStatePulse;
	r->callback = cb;
	r->opaque = opaque;
	r->spsPlay = reqSPSPlay;
	r->spsRec = reqSPSRec;
	r->channelsPlay = reqChannelsPlay;
	r->channelsRec = reqChannelsRec;
	r->sourceNamePlay = outputSelect?strdup(outputSelect):0;
	r->sourceNameRec = inputSelect?strdup(inputSelect):0;

	r->play = 0;
	r->rec = 0;
	r->buffer = sugBufferSize;

	printf ("Pulse: from: [O/I] %s/%s (%s) / (%d,%d)x(%d,%d) (%d)\n", r->sourceNamePlay, r->sourceNameRec, title, r->spsPlay, r->spsRec, r->channelsPlay, r->channelsRec, r->buffer );

	memset( &ss, 0, sizeof( ss ) );

	ss.format = PA_SAMPLE_S16NE;

	r->pa_ready = 0;
	pa_context_set_state_callback(r->pa_ctx, pa_state_cb, &r->pa_ready);

	while (r->pa_ready == 0)
	{
		pa_mainloop_iterate(r->pa_ml, 1, NULL);
	}

	int bufBytesPlay = r->buffer * sizeof(short) * r->channelsPlay;
	int bufBytesRec = r->buffer * sizeof(short) * r->channelsRec;

	if( r->channelsPlay )
	{
		ss.channels = r->channelsPlay;
		ss.rate = r->spsPlay;

		if (!(r->play = pa_stream_new(r->pa_ctx, "Play", &ss, NULL))) {
			error = -3; //XXX ??? TODO
			fprintf(stderr, __FILE__": pa_simple_new() failed: %s\n", pa_strerror(error));
			goto fail;
		}

		pa_stream_set_underflow_callback(r->play, stream_underflow_cb, NULL);
		pa_stream_set_write_callback(r->play, stream_request_cb, r );

		/* The absolute maximum number of bytes that can be stored in the buffer.
		 * If this value is exceeded then data will be lost. It is recommended to
		 * pass (uint32_t) -1 here which will cause the server to fill in the
		 * maximum possible value.*/
		bufattr.maxlength = bufBytesPlay*3;

		/* The target fill level of the playback buffer. The server will only send
		 * requests for more data as long as the buffer has less than this number of
		 * bytes of data. If you pass (uint32_t) -1 (which is recommended) here the
		 * server will choose the longest target buffer fill level possible to minimize
		 * the number of necessary wakeups and maximize drop-out safety. This can exceed
		 * 2s of buffering. For low-latency applications or applications where latency
		 * matters you should pass a proper value here. */
		bufattr.tlength = bufBytesPlay*3;

		/* Number of bytes that need to be in the buffer before playback will commence.
		 * Start of playback can be forced using pa_stream_trigger() even though the
		 * prebuffer size hasn't been reached. If a buffer underrun occurs, this
		 * prebuffering will be again enabled. If the playback shall never stop in case
		 * of a buffer underrun, this value should be set to 0. In that case the read
		 * index of the output buffer overtakes the write index, and hence the fill
		 * level of the buffer is negative. If you pass (uint32_t) -1 here (which is
		 * recommended) the server will choose the same value as tlength here. */
		bufattr.prebuf = (uint32_t)-1;

		/* Minimum free number of the bytes in the playback buffer before the server
		 * will request more data. It is recommended to fill in (uint32_t) -1 here. This
		 * value influences how much time the sound server has to move data from the
		 * per-stream server-side playback buffer to the hardware playback buffer. */
		bufattr.minreq = (uint32_t)-1;

		/* Maximum number of bytes that the server will push in one chunk for record
		 * streams. If you pass (uint32_t) -1 (which is recommended) here, the server
		 * will choose the longest fragment setting possible to minimize the number of
		 * necessary wakeups and maximize drop-out safety. This can exceed 2s of
		 * buffering. For low-latency applications or applications where latency matters
		 * you should pass a proper value here. */
		bufattr.fragsize = (uint32_t)-1;

		int ret = pa_stream_connect_playback(r->play, r->sourceNamePlay, &bufattr,
				                    // PA_STREAM_INTERPOLATE_TIMING
				                    // |PA_STREAM_ADJUST_LATENCY //Some servers don't like the adjust_latency flag.
				                    // |PA_STREAM_AUTO_TIMING_UPDATE, NULL, NULL);
					PA_STREAM_NOFLAGS, NULL, NULL );
		if( ret < 0 )
		{
			fprintf(stderr, __FILE__": (PLAY) pa_stream_connect_playback() failed: %s\n", pa_strerror(ret));
			goto fail;
		}

	}

	if( r->channelsRec )
	{
		ss.channels = r->channelsRec;
		ss.rate = r->spsRec;

		if (!(r->rec = pa_stream_new(r->pa_ctx, "Record", &ss, NULL))) {
			error = -3; //XXX ??? TODO
			fprintf(stderr, __FILE__": pa_simple_new() failed: %s\n", pa_strerror(error));
			goto fail;
		}

		pa_stream_set_read_callback(r->rec, stream_record_cb, r );

		bufattr.fragsize = bufBytesRec;
		bufattr.maxlength = (uint32_t)-1;//(uint32_t)-1; //XXX: Todo, should this be low?
		bufattr.minreq = bufBytesRec;
		bufattr.prebuf = (uint32_t)-1;
		bufattr.tlength = bufBytesRec*3;
		int ret = pa_stream_connect_record(r->rec, r->sourceNameRec, &bufattr, 
					                      // PA_STREAM_INTERPOLATE_TIMING
										  PA_STREAM_ADJUST_LATENCY  //Some servers don't like the adjust_latency flag.
										  // PA_STREAM_AUTO_TIMING_UPDATE
										  // PA_STREAM_NOFLAGS
				);

		printf( "PA REC RES: %d\n", ret );

		if( ret < 0 )
		{
			fprintf(stderr, __FILE__": (REC) pa_stream_connect_playback() failed: %s\n", pa_strerror(ret));
			goto fail;
		}
	}

	printf( "Pulse initialized.\n" );


	r->thread = OGCreateThread( CNFAThread, r );


	if( r->play )
	{
		stream_request_cb( r->play, bufBytesPlay, r );
	}

	return r;

fail:
	if( r )
	{
		if( r->play ) pa_xfree (r->play);
		if( r->rec ) pa_xfree (r->rec);
		free( r );
	}
	return 0;
}



REGISTER_CNFA( PulseCNFA, 11, "PULSE", InitCNFAPulse );

#endif
#elif defined(__APPLE__)
#if defined(PULSEAUDIO)
//Copyright 2015-2020 <>< Charles Lohr under the MIT/x11, NewBSD or ColorChord License.  You choose.

//This file is really rough.  Full duplex doesn't seem to work hardly at all.


#include "os_generic.h"
#include <stdlib.h>

#include <pulse/simple.h>
#include <pulse/pulseaudio.h>
#include <pulse/error.h>
#include <stdio.h>
#include <string.h>

#define BUFFERSETS 3


//from http://www.freedesktop.org/wiki/Software/PulseAudio/Documentation/Developer/Clients/Samples/AsyncPlayback/
//also http://maemo.org/api_refs/5.0/5.0-final/pulseaudio/pacat_8c-example.html


struct CNFADriverPulse
{
	void (*CloseFn)( void * object );
	int (*StateFn)( void * object );
	CNFACBType callback;
	short channelsPlay;
	short channelsRec;
	int spsPlay;
	int spsRec;
	void * opaque;

	char * sourceNamePlay;
	char * sourceNameRec;

	og_thread_t thread;
 	pa_stream *  	play;
 	pa_stream *  	rec;
	pa_context *  pa_ctx;
	pa_mainloop *pa_ml;
	int pa_ready;
	int buffer;
	//More fields may exist on a per-sound-driver basis
};




int CNFAStatePulse( void * v )
{
	struct CNFADriverPulse * soundobject = (struct CNFADriverPulse *)v;
	return ((soundobject->play)?2:0) | ((soundobject->rec)?1:0);
}

void CloseCNFAPulse( void * v )
{
	struct CNFADriverPulse * r = (struct CNFADriverPulse *)v;
	if( r )
	{
		OGCancelThread( r->thread );

		OGUSleep(2000);

		if( r->play )
		{
			pa_stream_unref (r->play);
			r->play = 0;
		}

		if( r->rec )
		{
			pa_stream_unref (r->rec);
			r->rec = 0;
		}

		OGUSleep(2000);

		if( r->sourceNamePlay ) free( r->sourceNamePlay );
		if( r->sourceNameRec ) free( r->sourceNameRec );
		free( r );
	}
}

static void * CNFAThread( void * v )
{
	struct CNFADriverPulse * r = (struct CNFADriverPulse*)v;
	while(1)
	{
		pa_mainloop_iterate( r->pa_ml, 1, NULL );
	}
	return 0;
}

static void stream_request_cb(pa_stream *s, size_t length, void *userdata)
{
	struct CNFADriverPulse * r = (struct CNFADriverPulse*)userdata;
	if( !r->play )
	{
		return;
	}
	short bufp[length*r->channelsPlay/sizeof(short)];
	r->callback( (struct CNFADriver*)r, bufp, 0, length/(sizeof(short)*r->channelsPlay), 0 );
	pa_stream_write(r->play, &bufp[0], length, NULL, 0LL, PA_SEEK_RELATIVE);
}


static void stream_record_cb(pa_stream *s, size_t length, void *userdata)
{
	struct CNFADriverPulse * r = (struct CNFADriverPulse*)userdata;

	uint16_t * bufr;

    if (pa_stream_peek(r->rec, (const void**)&bufr, &length) < 0) {
        fprintf(stderr, ("pa_stream_peek() failed: %s\n"), pa_strerror(pa_context_errno(r->pa_ctx)));
        return;
    }

	short * buffer;
    buffer = (short*)pa_xmalloc(length);
    memcpy(buffer, bufr, length);
	pa_stream_drop(r->rec);
	r->callback( (struct CNFADriver*)r, 0, buffer, 0, length/(sizeof(short)*r->channelsRec) );
	pa_xfree( buffer );
}



static void stream_underflow_cb(pa_stream *s, void *userdata) {
  printf("underflow\n");
}


void pa_state_cb(pa_context *c, void *userdata) {
	pa_context_state_t state;
	int *pa_ready = (int*)userdata;
	state = pa_context_get_state(c);
	switch  (state) {
		// These are just here for reference
		case PA_CONTEXT_UNCONNECTED:
		case PA_CONTEXT_CONNECTING:
		case PA_CONTEXT_AUTHORIZING:
		case PA_CONTEXT_SETTING_NAME:
		default:
			break;
		case PA_CONTEXT_FAILED:
		case PA_CONTEXT_TERMINATED:
			*pa_ready = 2;
			break;
		case PA_CONTEXT_READY:
			*pa_ready = 1;
		break;
	}
}


void * InitCNFAPulse( CNFACBType cb, const char * your_name, int reqSPSPlay, int reqSPSRec, int reqChannelsPlay, int reqChannelsRec, int sugBufferSize, const char * outputSelect, const char * inputSelect, void * opaque )
{
	static pa_buffer_attr bufattr;
	static pa_sample_spec ss;
	int error;
	pa_mainloop_api *pa_mlapi;
	const char * title = your_name;

	struct CNFADriverPulse * r = (struct CNFADriverPulse *)malloc( sizeof( struct CNFADriverPulse ) );

	r->pa_ml = pa_mainloop_new();
	if( !r->pa_ml )
	{
		fprintf( stderr, "Failed to initialize pa_mainloop_new()\n" );
		goto fail;
	}

	pa_mlapi = pa_mainloop_get_api(r->pa_ml);
	if( !pa_mlapi )
	{
		fprintf( stderr, "Failed to initialize pa_mainloop_get_api()\n" );
		goto fail;
	}

	r->pa_ctx = pa_context_new(pa_mlapi, title );
	pa_context_connect(r->pa_ctx, NULL, PA_CONTEXT_NOFLAGS, NULL);

	//TODO: pa_context_set_state_callback

	r->CloseFn = CloseCNFAPulse;
	r->StateFn = CNFAStatePulse;
	r->callback = cb;
	r->opaque = opaque;
	r->spsPlay = reqSPSPlay;
	r->spsRec = reqSPSRec;
	r->channelsPlay = reqChannelsPlay;
	r->channelsRec = reqChannelsRec;
	r->sourceNamePlay = outputSelect?strdup(outputSelect):0;
	r->sourceNameRec = inputSelect?strdup(inputSelect):0;

	r->play = 0;
	r->rec = 0;
	r->buffer = sugBufferSize;

	printf ("Pulse: from: [O/I] %s/%s (%s) / (%d,%d)x(%d,%d) (%d)\n", r->sourceNamePlay, r->sourceNameRec, title, r->spsPlay, r->spsRec, r->channelsPlay, r->channelsRec, r->buffer );

	memset( &ss, 0, sizeof( ss ) );

	ss.format = PA_SAMPLE_S16NE;

	r->pa_ready = 0;
	pa_context_set_state_callback(r->pa_ctx, pa_state_cb, &r->pa_ready);

	while (r->pa_ready == 0)
	{
		pa_mainloop_iterate(r->pa_ml, 1, NULL);
	}

	int bufBytesPlay = r->buffer * sizeof(short) * r->channelsPlay;
	int bufBytesRec = r->buffer * sizeof(short) * r->channelsRec;

	if( r->channelsPlay )
	{
		ss.channels = r->channelsPlay;
		ss.rate = r->spsPlay;

		if (!(r->play = pa_stream_new(r->pa_ctx, "Play", &ss, NULL))) {
			error = -3; //XXX ??? TODO
			fprintf(stderr, __FILE__": pa_simple_new() failed: %s\n", pa_strerror(error));
			goto fail;
		}

		pa_stream_set_underflow_callback(r->play, stream_underflow_cb, NULL);
		pa_stream_set_write_callback(r->play, stream_request_cb, r );

		/* The absolute maximum number of bytes that can be stored in the buffer.
		 * If this value is exceeded then data will be lost. It is recommended to
		 * pass (uint32_t) -1 here which will cause the server to fill in the
		 * maximum possible value.*/
		bufattr.maxlength = bufBytesPlay*3;

		/* The target fill level of the playback buffer. The server will only send
		 * requests for more data as long as the buffer has less than this number of
		 * bytes of data. If you pass (uint32_t) -1 (which is recommended) here the
		 * server will choose the longest target buffer fill level possible to minimize
		 * the number of necessary wakeups and maximize drop-out safety. This can exceed
		 * 2s of buffering. For low-latency applications or applications where latency
		 * matters you should pass a proper value here. */
		bufattr.tlength = bufBytesPlay*3;

		/* Number of bytes that need to be in the buffer before playback will commence.
		 * Start of playback can be forced using pa_stream_trigger() even though the
		 * prebuffer size hasn't been reached. If a buffer underrun occurs, this
		 * prebuffering will be again enabled. If the playback shall never stop in case
		 * of a buffer underrun, this value should be set to 0. In that case the read
		 * index of the output buffer overtakes the write index, and hence the fill
		 * level of the buffer is negative. If you pass (uint32_t) -1 here (which is
		 * recommended) the server will choose the same value as tlength here. */
		bufattr.prebuf = (uint32_t)-1;

		/* Minimum free number of the bytes in the playback buffer before the server
		 * will request more data. It is recommended to fill in (uint32_t) -1 here. This
		 * value influences how much time the sound server has to move data from the
		 * per-stream server-side playback buffer to the hardware playback buffer. */
		bufattr.minreq = (uint32_t)-1;

		/* Maximum number of bytes that the server will push in one chunk for record
		 * streams. If you pass (uint32_t) -1 (which is recommended) here, the server
		 * will choose the longest fragment setting possible to minimize the number of
		 * necessary wakeups and maximize drop-out safety. This can exceed 2s of
		 * buffering. For low-latency applications or applications where latency matters
		 * you should pass a proper value here. */
		bufattr.fragsize = (uint32_t)-1;

		int ret = pa_stream_connect_playback(r->play, r->sourceNamePlay, &bufattr,
				                    // PA_STREAM_INTERPOLATE_TIMING
				                    // |PA_STREAM_ADJUST_LATENCY //Some servers don't like the adjust_latency flag.
				                    // |PA_STREAM_AUTO_TIMING_UPDATE, NULL, NULL);
					PA_STREAM_NOFLAGS, NULL, NULL );
		if( ret < 0 )
		{
			fprintf(stderr, __FILE__": (PLAY) pa_stream_connect_playback() failed: %s\n", pa_strerror(ret));
			goto fail;
		}

	}

	if( r->channelsRec )
	{
		ss.channels = r->channelsRec;
		ss.rate = r->spsRec;

		if (!(r->rec = pa_stream_new(r->pa_ctx, "Record", &ss, NULL))) {
			error = -3; //XXX ??? TODO
			fprintf(stderr, __FILE__": pa_simple_new() failed: %s\n", pa_strerror(error));
			goto fail;
		}

		pa_stream_set_read_callback(r->rec, stream_record_cb, r );

		bufattr.fragsize = bufBytesRec;
		bufattr.maxlength = (uint32_t)-1;//(uint32_t)-1; //XXX: Todo, should this be low?
		bufattr.minreq = bufBytesRec;
		bufattr.prebuf = (uint32_t)-1;
		bufattr.tlength = bufBytesRec*3;
		int ret = pa_stream_connect_record(r->rec, r->sourceNameRec, &bufattr, 
					                      // PA_STREAM_INTERPOLATE_TIMING
										  PA_STREAM_ADJUST_LATENCY  //Some servers don't like the adjust_latency flag.
										  // PA_STREAM_AUTO_TIMING_UPDATE
										  // PA_STREAM_NOFLAGS
				);

		printf( "PA REC RES: %d\n", ret );

		if( ret < 0 )
		{
			fprintf(stderr, __FILE__": (REC) pa_stream_connect_playback() failed: %s\n", pa_strerror(ret));
			goto fail;
		}
	}

	printf( "Pulse initialized.\n" );


	r->thread = OGCreateThread( CNFAThread, r );


	if( r->play )
	{
		stream_request_cb( r->play, bufBytesPlay, r );
	}

	return r;

fail:
	if( r )
	{
		if( r->play ) pa_xfree (r->play);
		if( r->rec ) pa_xfree (r->rec);
		free( r );
	}
	return 0;
}



REGISTER_CNFA( PulseCNFA, 11, "PULSE", InitCNFAPulse );

#endif
#endif
#endif


#ifdef __cplusplus
};
#endif



#endif


